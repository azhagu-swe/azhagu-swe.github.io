---
title: "Geohash Proximity Engine"
date: "2024-05-20"
description: "Engineered a high-performance Java utility by converting Python's Proximity Hash library, achieving a 20% reduction in geohash generation time and enabling high-speed geospatial lookups."
tags: ["Java", "Spring Boot", "Maven", "Geohash Algorithm"]
image: "https://placehold.co/600x400/1E1E1E/FFC107?text=Proximity+Hash"
demoUrl: "https://github.com/azhagu-swe/proximityhash-javas"
repoUrl: "https://github.com/azhagu-swe/proximityhash-javas"
published: true
---

### The Problem

In the world of digital advertising and logistics, the ability to perform high-speed geospatial queries is critical. For a Demand-Side Platform (DSP) needing to target mobile devices based on their location, the performance of geohash lookups is a major bottleneck. The existing solution, based on a Python library, was not fast enough to handle the scale of over 1 million devices, leading to increased latency and missed opportunities. The challenge was to create a significantly faster, more efficient geospatial utility suitable for a high-throughput production environment.

### My Solution

I engineered a high-performance Java utility by converting and optimizing the Python Proximity Hash library. The core of the solution lies in the **Geohash algorithm**, a hierarchical spatial data structure that subdivides space into a grid, allowing for incredibly efficient proximity searches.

A Geohash is a geocoding system that encodes a geographic location into a short string of letters and digits. This is a powerful application of a Z-order curve, which maps multidimensional data to a single dimension while preserving the locality of the data points.

My implementation focused on two key areas:

1.  **Performance Optimization:** By leveraging Java's performance characteristics and optimizing the core algorithm, I was able to reduce the geohash generation time by **20%** compared to the original Python version.
2.  **Production-Ready Utility:** The utility was built as a robust Java library using Maven for dependency management, making it easy to integrate into the existing Spring Boot-based DSP.

Here is a sample of how the core logic can be used to generate geohashes for a given location and radius:

```java
public class GeohashExample {
    public static void main(String[] args) {
        double latitude = 24.189992;
        double longitude = 55.762293;
        double radius = 5000; // in meters
        int precision = 6;

        // This would call the core library function to get all geohashes within the radius
        System.out.println(
            "Geohashes for the given location: " + 
            createGeohash(latitude, longitude, radius, precision, false, 1, 12)
        );
    }

    // A placeholder for the actual library function
    public static String createGeohash(double lat, double lon, double rad, int prec, boolean flag, int i, int j) {
        // The actual library contains the complex logic for geohash generation...
        return "u4pruy";
    }
}
```

### Outcome

The Geohash Proximity Engine was successfully deployed into a production Demand-Side Platform. The 20% reduction in generation time and the overall performance improvements enabled the system to efficiently target over **1 million mobile devices** via high-speed geohash lookups. This project not only solved a critical performance bottleneck but also demonstrated the significant advantages of using a compiled language like Java for computationally intensive tasks in a large-scale system.
